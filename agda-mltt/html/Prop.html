<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Prop</title><link rel="stylesheet" href="Agda.css"></head><body><pre><a id="1" class="Keyword">open</a> <a id="6" class="Keyword">import</a> <a id="13" href="Base.html" class="Module">Base</a>

<a id="19" class="Comment">-- Agda-MLTT library.</a>
<a id="41" class="Comment">-- Author: Mario Román.</a>

<a id="66" class="Comment">-- Prop.  Proposition types. A type is a proposition if we can</a>
<a id="129" class="Comment">-- construct a function that provides an equality between any two of</a>
<a id="198" class="Comment">-- its elements. We define propositional truncation and some truncated</a>
<a id="269" class="Comment">-- logical connectives explicitly hoping to provide clarity on how</a>
<a id="336" class="Comment">-- these types can be constructed inside the system.</a>

<a id="390" class="Keyword">module</a> <a id="397" href="Prop.html" class="Module">Prop</a> <a id="402" class="Keyword">where</a>

<a id="409" class="Comment">-- Definition of Proposition.</a>
<a id="isProp" href="Prop.html#isProp" class="Function">isProp</a> <a id="446" class="Symbol">:</a> <a id="448" class="PrimitiveType">Set</a> <a id="452" class="Symbol">→</a> <a id="454" class="PrimitiveType">Set</a>
<a id="458" href="Prop.html#isProp" class="Function">isProp</a> <a id="465" href="Prop.html#465" class="Bound">A</a> <a id="467" class="Symbol">=</a> <a id="469" class="Symbol">((</a><a id="471" href="Prop.html#471" class="Bound">x</a> <a id="473" href="Prop.html#473" class="Bound">y</a> <a id="475" class="Symbol">:</a> <a id="477" href="Prop.html#465" class="Bound">A</a><a id="478" class="Symbol">)</a> <a id="480" class="Symbol">→</a> <a id="482" href="Prop.html#471" class="Bound">x</a> <a id="484" href="Base.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="486" href="Prop.html#473" class="Bound">y</a><a id="487" class="Symbol">)</a>

<a id="490" class="Comment">-- The product of two propositions is itself a proposition.</a>
<a id="prod-isProp" href="Prop.html#prod-isProp" class="Function">prod-isProp</a> <a id="562" class="Symbol">:</a> <a id="564" class="Symbol">{</a><a id="565" href="Prop.html#565" class="Bound">A</a> <a id="567" href="Prop.html#567" class="Bound">B</a> <a id="569" class="Symbol">:</a> <a id="571" class="PrimitiveType">Set</a><a id="574" class="Symbol">}</a> <a id="576" class="Symbol">→</a> <a id="578" href="Prop.html#isProp" class="Function">isProp</a> <a id="585" href="Prop.html#565" class="Bound">A</a> <a id="587" class="Symbol">→</a> <a id="589" href="Prop.html#isProp" class="Function">isProp</a> <a id="596" href="Prop.html#567" class="Bound">B</a> <a id="598" class="Symbol">→</a> <a id="600" href="Prop.html#isProp" class="Function">isProp</a> <a id="607" class="Symbol">(</a><a id="608" href="Prop.html#565" class="Bound">A</a> <a id="610" href="Base.html#_%C3%97_" class="Function Operator">×</a> <a id="612" href="Prop.html#567" class="Bound">B</a><a id="613" class="Symbol">)</a>
<a id="615" href="Prop.html#prod-isProp" class="Function">prod-isProp</a> <a id="627" href="Prop.html#627" class="Bound">pa</a> <a id="630" href="Prop.html#630" class="Bound">pb</a> <a id="633" class="Symbol">(</a><a id="634" href="Prop.html#634" class="Bound">a</a> <a id="636" href="Base.html#%CE%A3._%2C_" class="InductiveConstructor Operator">,</a> <a id="638" href="Prop.html#638" class="Bound">b</a><a id="639" class="Symbol">)</a> <a id="641" class="Symbol">(</a><a id="642" href="Prop.html#642" class="Bound">c</a> <a id="644" href="Base.html#%CE%A3._%2C_" class="InductiveConstructor Operator">,</a> <a id="646" href="Prop.html#646" class="Bound">d</a><a id="647" class="Symbol">)</a> <a id="649" class="Keyword">with</a> <a id="654" class="Symbol">(</a><a id="655" href="Prop.html#627" class="Bound">pa</a> <a id="658" href="Prop.html#634" class="Bound">a</a> <a id="660" href="Prop.html#642" class="Bound">c</a><a id="661" class="Symbol">)</a> <a id="663" class="Symbol">|</a> <a id="665" class="Symbol">(</a><a id="666" href="Prop.html#630" class="Bound">pb</a> <a id="669" href="Prop.html#638" class="Bound">b</a> <a id="671" href="Prop.html#646" class="Bound">d</a><a id="672" class="Symbol">)</a>
<a id="674" href="Prop.html#prod-isProp" class="Function">prod-isProp</a> <a id="686" href="Prop.html#686" class="Bound">pa</a> <a id="689" href="Prop.html#689" class="Bound">pb</a> <a id="692" class="Symbol">(</a><a id="693" href="Prop.html#693" class="Bound">a</a> <a id="695" href="Base.html#%CE%A3._%2C_" class="InductiveConstructor Operator">,</a> <a id="697" href="Prop.html#697" class="Bound">b</a><a id="698" class="Symbol">)</a> <a id="700" class="Symbol">(</a><a id="701" class="DottedPattern Symbol">.</a><a id="702" href="Prop.html#693" class="DottedPattern Bound">a</a> <a id="704" href="Base.html#%CE%A3._%2C_" class="InductiveConstructor Operator">,</a> <a id="706" class="DottedPattern Symbol">.</a><a id="707" href="Prop.html#697" class="DottedPattern Bound">b</a><a id="708" class="Symbol">)</a> <a id="710" class="Symbol">|</a> <a id="712" href="Base.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a> <a id="717" class="Symbol">|</a> <a id="719" href="Base.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a> <a id="724" class="Symbol">=</a> <a id="726" href="Base.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a>

<a id="732" class="Comment">-- The implication of a family of propositions is itself a proposition.</a>
<a id="pi-isProp" href="Prop.html#pi-isProp" class="Function">pi-isProp</a> <a id="814" class="Symbol">:</a> <a id="816" class="Symbol">{</a><a id="817" href="Prop.html#817" class="Bound">A</a> <a id="819" class="Symbol">:</a> <a id="821" class="PrimitiveType">Set</a><a id="824" class="Symbol">}</a> <a id="826" class="Symbol">→</a> <a id="828" class="Symbol">{</a><a id="829" href="Prop.html#829" class="Bound">B</a> <a id="831" class="Symbol">:</a> <a id="833" href="Prop.html#817" class="Bound">A</a> <a id="835" class="Symbol">→</a> <a id="837" class="PrimitiveType">Set</a><a id="840" class="Symbol">}</a> <a id="842" class="Symbol">→</a> <a id="844" class="Symbol">((</a><a id="846" href="Prop.html#846" class="Bound">a</a> <a id="848" class="Symbol">:</a> <a id="850" href="Prop.html#817" class="Bound">A</a><a id="851" class="Symbol">)</a> <a id="853" class="Symbol">→</a> <a id="855" href="Prop.html#isProp" class="Function">isProp</a> <a id="862" class="Symbol">(</a><a id="863" href="Prop.html#829" class="Bound">B</a> <a id="865" href="Prop.html#846" class="Bound">a</a><a id="866" class="Symbol">))</a> <a id="869" class="Symbol">→</a> <a id="871" href="Prop.html#isProp" class="Function">isProp</a> <a id="878" class="Symbol">((</a><a id="880" href="Prop.html#880" class="Bound">a</a> <a id="882" class="Symbol">:</a> <a id="884" href="Prop.html#817" class="Bound">A</a><a id="885" class="Symbol">)</a> <a id="887" class="Symbol">→</a> <a id="889" href="Prop.html#829" class="Bound">B</a> <a id="891" href="Prop.html#880" class="Bound">a</a><a id="892" class="Symbol">)</a>
<a id="894" href="Prop.html#pi-isProp" class="Function">pi-isProp</a> <a id="904" href="Prop.html#904" class="Bound">p</a> <a id="906" href="Prop.html#906" class="Bound">f</a> <a id="908" href="Prop.html#908" class="Bound">g</a> <a id="910" class="Symbol">=</a> <a id="912" href="Base.html#funext" class="Postulate">funext</a> <a id="919" class="Symbol">λ</a> <a id="921" href="Prop.html#921" class="Bound">x</a> <a id="923" class="Symbol">→</a> <a id="925" href="Prop.html#904" class="Bound">p</a> <a id="927" href="Prop.html#921" class="Bound">x</a> <a id="929" class="Symbol">(</a><a id="930" href="Prop.html#906" class="Bound">f</a> <a id="932" href="Prop.html#921" class="Bound">x</a><a id="933" class="Symbol">)</a> <a id="935" class="Symbol">(</a><a id="936" href="Prop.html#908" class="Bound">g</a> <a id="938" href="Prop.html#921" class="Bound">x</a><a id="939" class="Symbol">)</a>

<a id="942" class="Comment">-- The negation of a proposition is a proposition.</a>
<a id="not-isProp" href="Prop.html#not-isProp" class="Function">not-isProp</a> <a id="1004" class="Symbol">:</a> <a id="1006" class="Symbol">{</a><a id="1007" href="Prop.html#1007" class="Bound">A</a> <a id="1009" class="Symbol">:</a> <a id="1011" class="PrimitiveType">Set</a><a id="1014" class="Symbol">}</a> <a id="1016" class="Symbol">→</a> <a id="1018" href="Prop.html#isProp" class="Function">isProp</a> <a id="1025" class="Symbol">(</a><a id="1026" href="Base.html#%C2%AC" class="Function">¬</a> <a id="1028" href="Prop.html#1007" class="Bound">A</a><a id="1029" class="Symbol">)</a>
<a id="1031" href="Prop.html#not-isProp" class="Function">not-isProp</a> <a id="1042" class="Symbol">=</a> <a id="1044" href="Prop.html#pi-isProp" class="Function">pi-isProp</a> <a id="1054" class="Symbol">(λ</a> <a id="1057" href="Prop.html#1057" class="Bound">a</a> <a id="1059" href="Prop.html#1059" class="Bound">x</a> <a id="1061" class="Symbol">→</a> <a id="1063" class="Symbol">λ</a> <a id="1065" class="Symbol">())</a>


<a id="1071" class="Keyword">postulate</a>
  <a id="1083" class="Comment">-- We say that two propositions are equal if they follow from each</a>
  <a id="1152" class="Comment">-- other.  This notion of equality is called propositional</a>
  <a id="1213" class="Comment">-- extensionality.</a>
  <a id="propext" href="Prop.html#propext" class="Postulate">propext</a> <a id="1242" class="Symbol">:</a> <a id="1244" class="Symbol">{</a><a id="1245" href="Prop.html#1245" class="Bound">A</a> <a id="1247" href="Prop.html#1247" class="Bound">B</a> <a id="1249" class="Symbol">:</a> <a id="1251" class="PrimitiveType">Set</a><a id="1254" class="Symbol">}</a> <a id="1256" class="Symbol">→</a> <a id="1258" href="Prop.html#isProp" class="Function">isProp</a> <a id="1265" href="Prop.html#1245" class="Bound">A</a> <a id="1267" class="Symbol">→</a> <a id="1269" href="Prop.html#isProp" class="Function">isProp</a> <a id="1276" href="Prop.html#1247" class="Bound">B</a> <a id="1278" class="Symbol">→</a> <a id="1280" class="Symbol">(</a><a id="1281" href="Prop.html#1245" class="Bound">A</a> <a id="1283" class="Symbol">→</a> <a id="1285" href="Prop.html#1247" class="Bound">B</a><a id="1286" class="Symbol">)</a> <a id="1288" class="Symbol">→</a> <a id="1290" class="Symbol">(</a><a id="1291" href="Prop.html#1247" class="Bound">B</a> <a id="1293" class="Symbol">→</a> <a id="1295" href="Prop.html#1245" class="Bound">A</a><a id="1296" class="Symbol">)</a> <a id="1298" class="Symbol">→</a> <a id="1300" href="Prop.html#1245" class="Bound">A</a> <a id="1302" href="Base.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="1304" href="Prop.html#1247" class="Bound">B</a>


<a id="1308" class="Keyword">module</a> <a id="Truncation" href="Prop.html#Truncation" class="Module">Truncation</a> <a id="1326" class="Keyword">where</a>
  <a id="1334" class="Comment">-- A type A may have multiple distinct elements, witnessing</a>
  <a id="1396" class="Comment">-- different proofs of the same fact. We can, however truncate a</a>
  <a id="1463" class="Comment">-- type A into a proposition ∥A∥ by postulating that any two of its</a>
  <a id="1533" class="Comment">-- elements must be equal.</a>
  
  <a id="1565" class="Keyword">private</a>
    <a id="1577" class="Comment">-- This is an instance of a higher inductive type, defined with</a>
    <a id="1645" class="Comment">-- equalities between any two members. We implement it using</a>
    <a id="1710" class="Comment">-- private constuctors (this is called Dan Licata&#39;s trick in</a>
    <a id="1775" class="Comment">-- literature).</a>
    <a id="1795" class="Keyword">data</a> <a id="Truncation.!∥_∥" href="Prop.html#Truncation.%21%E2%88%A5_%E2%88%A5" class="Datatype Operator">!∥_∥</a> <a id="1805" class="Symbol">(</a><a id="1806" href="Prop.html#1806" class="Bound">A</a> <a id="1808" class="Symbol">:</a> <a id="1810" class="PrimitiveType">Set</a><a id="1813" class="Symbol">)</a> <a id="1815" class="Symbol">:</a> <a id="1817" class="PrimitiveType">Set</a> <a id="1821" class="Keyword">where</a>
      <a id="Truncation.!∥_∥.!∣_∣" href="Prop.html#Truncation.%21%E2%88%A5_%E2%88%A5.%21%E2%88%A3_%E2%88%A3" class="InductiveConstructor Operator">!∣_∣</a> <a id="1838" class="Symbol">:</a> <a id="1840" href="Prop.html#1806" class="Bound">A</a> <a id="1842" class="Symbol">→</a> <a id="1844" href="Prop.html#Truncation.%21%E2%88%A5_%E2%88%A5" class="Datatype Operator">!∥</a> <a id="1847" href="Prop.html#1806" class="Bound">A</a> <a id="1849" href="Prop.html#Truncation.%21%E2%88%A5_%E2%88%A5" class="Datatype Operator">∥</a>

  <a id="1854" class="Comment">-- Constructor of a truncated type.</a>
  <a id="Truncation.∥_∥" href="Prop.html#Truncation.%E2%88%A5_%E2%88%A5" class="Function Operator">∥_∥</a> <a id="1896" class="Symbol">:</a> <a id="1898" class="Symbol">(</a><a id="1899" href="Prop.html#1899" class="Bound">A</a> <a id="1901" class="Symbol">:</a> <a id="1903" class="PrimitiveType">Set</a><a id="1906" class="Symbol">)</a> <a id="1908" class="Symbol">→</a> <a id="1910" class="PrimitiveType">Set</a>
  <a id="1916" href="Prop.html#Truncation.%E2%88%A5_%E2%88%A5" class="Function Operator">∥</a> <a id="1918" href="Prop.html#1918" class="Bound">A</a> <a id="1920" href="Prop.html#Truncation.%E2%88%A5_%E2%88%A5" class="Function Operator">∥</a> <a id="1922" class="Symbol">=</a> <a id="1924" href="Prop.html#Truncation.%21%E2%88%A5_%E2%88%A5" class="Datatype Operator">!∥</a> <a id="1927" href="Prop.html#1918" class="Bound">A</a> <a id="1929" href="Prop.html#Truncation.%21%E2%88%A5_%E2%88%A5" class="Datatype Operator">∥</a>

  <a id="1934" class="Comment">-- If x is an element of A, then |x| is an element of its truncated</a>
  <a id="2004" class="Comment">-- type. Note, however, that |x|=|y| for any two, potentially</a>
  <a id="2068" class="Comment">-- different x,y:A.</a>
  <a id="Truncation.∣_∣" href="Prop.html#Truncation.%E2%88%A3_%E2%88%A3" class="Function Operator">∣_∣</a> <a id="2094" class="Symbol">:</a> <a id="2096" class="Symbol">{</a><a id="2097" href="Prop.html#2097" class="Bound">X</a> <a id="2099" class="Symbol">:</a> <a id="2101" class="PrimitiveType">Set</a><a id="2104" class="Symbol">}</a> <a id="2106" class="Symbol">→</a> <a id="2108" href="Prop.html#2097" class="Bound">X</a> <a id="2110" class="Symbol">→</a> <a id="2112" href="Prop.html#Truncation.%E2%88%A5_%E2%88%A5" class="Function Operator">∥</a> <a id="2114" href="Prop.html#2097" class="Bound">X</a> <a id="2116" href="Prop.html#Truncation.%E2%88%A5_%E2%88%A5" class="Function Operator">∥</a>
  <a id="2120" href="Prop.html#Truncation.%E2%88%A3_%E2%88%A3" class="Function Operator">∣</a> <a id="2122" href="Prop.html#2122" class="Bound">x</a> <a id="2124" href="Prop.html#Truncation.%E2%88%A3_%E2%88%A3" class="Function Operator">∣</a> <a id="2126" class="Symbol">=</a> <a id="2128" href="Prop.html#Truncation.%21%E2%88%A5_%E2%88%A5.%21%E2%88%A3_%E2%88%A3" class="InductiveConstructor Operator">!∣</a> <a id="2131" href="Prop.html#2122" class="Bound">x</a> <a id="2133" href="Prop.html#Truncation.%21%E2%88%A5_%E2%88%A5.%21%E2%88%A3_%E2%88%A3" class="InductiveConstructor Operator">∣</a>
  
  <a id="2140" class="Comment">-- We postulate that any two elements of the truncated type are</a>
  <a id="2206" class="Comment">-- equal. </a>
  <a id="2219" class="Keyword">postulate</a> <a id="Truncation.trunc" href="Prop.html#Truncation.trunc" class="Postulate">trunc</a> <a id="2235" class="Symbol">:</a> <a id="2237" class="Symbol">{</a><a id="2238" href="Prop.html#2238" class="Bound">A</a> <a id="2240" class="Symbol">:</a> <a id="2242" class="PrimitiveType">Set</a><a id="2245" class="Symbol">}</a> <a id="2247" class="Symbol">→</a> <a id="2249" href="Prop.html#isProp" class="Function">isProp</a> <a id="2256" href="Prop.html#Truncation.%E2%88%A5_%E2%88%A5" class="Function Operator">∥</a> <a id="2258" href="Prop.html#2238" class="Bound">A</a> <a id="2260" href="Prop.html#Truncation.%E2%88%A5_%E2%88%A5" class="Function Operator">∥</a>

  <a id="2265" class="Comment">-- Recursion principle for truncated types. This is directly derived</a>
  <a id="2336" class="Comment">-- from the adjunction described in the text.</a>
  <a id="Truncation.trunc-rec" href="Prop.html#Truncation.trunc-rec" class="Function">trunc-rec</a> <a id="2394" class="Symbol">:</a> <a id="2396" class="Symbol">{</a><a id="2397" href="Prop.html#2397" class="Bound">A</a> <a id="2399" class="Symbol">:</a> <a id="2401" class="PrimitiveType">Set</a><a id="2404" class="Symbol">}</a> <a id="2406" class="Symbol">{</a><a id="2407" href="Prop.html#2407" class="Bound">P</a> <a id="2409" class="Symbol">:</a> <a id="2411" class="PrimitiveType">Set</a><a id="2414" class="Symbol">}</a> <a id="2416" class="Symbol">→</a> <a id="2418" href="Prop.html#isProp" class="Function">isProp</a> <a id="2425" href="Prop.html#2407" class="Bound">P</a>
   <a id="2430" class="Symbol">→</a> <a id="2432" class="Symbol">(</a> <a id="2434" href="Prop.html#2397" class="Bound">A</a>   <a id="2438" class="Symbol">→</a>  <a id="2441" href="Prop.html#2407" class="Bound">P</a><a id="2442" class="Symbol">)</a>
     <a id="2449" class="Comment">-----------</a>
   <a id="2464" class="Symbol">→</a> <a id="2466" href="Prop.html#Truncation.%E2%88%A5_%E2%88%A5" class="Function Operator">∥</a> <a id="2468" href="Prop.html#2397" class="Bound">A</a> <a id="2470" href="Prop.html#Truncation.%E2%88%A5_%E2%88%A5" class="Function Operator">∥</a> <a id="2472" class="Symbol">→</a>  <a id="2475" href="Prop.html#2407" class="Bound">P</a>
  <a id="2479" href="Prop.html#Truncation.trunc-rec" class="Function">trunc-rec</a> <a id="2489" class="Symbol">_</a> <a id="2491" href="Prop.html#2491" class="Bound">f</a> <a id="2493" href="Prop.html#Truncation.%21%E2%88%A5_%E2%88%A5.%21%E2%88%A3_%E2%88%A3" class="InductiveConstructor Operator">!∣</a> <a id="2496" href="Prop.html#2496" class="Bound">x</a> <a id="2498" href="Prop.html#Truncation.%21%E2%88%A5_%E2%88%A5.%21%E2%88%A3_%E2%88%A3" class="InductiveConstructor Operator">∣</a> <a id="2500" class="Symbol">=</a> <a id="2502" href="Prop.html#2491" class="Bound">f</a> <a id="2504" href="Prop.html#2496" class="Bound">x</a>

  <a id="2509" class="Comment">-- An easier-to-read variant of the recursion principle.</a>
  <a id="Truncation.trunc-elim" href="Prop.html#Truncation.trunc-elim" class="Function">trunc-elim</a> <a id="2579" class="Symbol">:</a> <a id="2581" class="Symbol">{</a><a id="2582" href="Prop.html#2582" class="Bound">A</a> <a id="2584" class="Symbol">:</a> <a id="2586" class="PrimitiveType">Set</a><a id="2589" class="Symbol">}</a> <a id="2591" class="Symbol">{</a><a id="2592" href="Prop.html#2592" class="Bound">P</a> <a id="2594" class="Symbol">:</a> <a id="2596" class="PrimitiveType">Set</a><a id="2599" class="Symbol">}</a> <a id="2601" class="Symbol">→</a> <a id="2603" href="Prop.html#Truncation.%E2%88%A5_%E2%88%A5" class="Function Operator">∥</a> <a id="2605" href="Prop.html#2582" class="Bound">A</a> <a id="2607" href="Prop.html#Truncation.%E2%88%A5_%E2%88%A5" class="Function Operator">∥</a> <a id="2609" class="Symbol">→</a> <a id="2611" href="Prop.html#isProp" class="Function">isProp</a> <a id="2618" href="Prop.html#2592" class="Bound">P</a> <a id="2620" class="Symbol">→</a> <a id="2622" class="Symbol">(</a><a id="2623" href="Prop.html#2582" class="Bound">A</a> <a id="2625" class="Symbol">→</a> <a id="2627" href="Prop.html#2592" class="Bound">P</a><a id="2628" class="Symbol">)</a> <a id="2630" class="Symbol">→</a> <a id="2632" href="Prop.html#2592" class="Bound">P</a>
  <a id="2636" href="Prop.html#Truncation.trunc-elim" class="Function">trunc-elim</a> <a id="2647" class="Symbol">=</a> <a id="2649" class="Symbol">λ</a> <a id="2651" href="Prop.html#2651" class="Bound">z</a> <a id="2653" href="Prop.html#2653" class="Bound">z₁</a> <a id="2656" href="Prop.html#2656" class="Bound">z₂</a> <a id="2659" class="Symbol">→</a> <a id="2661" href="Prop.html#Truncation.trunc-rec" class="Function">trunc-rec</a> <a id="2671" href="Prop.html#2653" class="Bound">z₁</a> <a id="2674" href="Prop.html#2656" class="Bound">z₂</a> <a id="2677" href="Prop.html#2651" class="Bound">z</a>
<a id="2679" class="Keyword">open</a> <a id="2684" href="Prop.html#Truncation" class="Module">Truncation</a> <a id="2695" class="Keyword">public</a>
  

<a id="2706" class="Keyword">module</a> <a id="Exists" href="Prop.html#Exists" class="Module">Exists</a> <a id="2720" class="Keyword">where</a>
  <a id="2728" class="Comment">-- The existential quantifier, in a classical sense, arises as a</a>
  <a id="2795" class="Comment">-- propositional truncation of the constructive existential</a>
  <a id="2857" class="Comment">-- quantifier.</a>
  <a id="2874" class="Keyword">private</a>
    <a id="2886" class="Comment">-- The existential quantifier is defined mirroring the dependent</a>
    <a id="2955" class="Comment">-- pair type. This is again an instance of a higher inductive</a>
    <a id="3021" class="Comment">-- type.</a>
    <a id="3034" class="Keyword">record</a> <a id="Exists.!Ex" href="Prop.html#Exists.%21Ex" class="Record">!Ex</a> <a id="3045" class="Symbol">(</a><a id="3046" href="Prop.html#3046" class="Bound">A</a> <a id="3048" class="Symbol">:</a> <a id="3050" class="PrimitiveType">Set</a><a id="3053" class="Symbol">)</a> <a id="3055" class="Symbol">(</a><a id="3056" href="Prop.html#3056" class="Bound">B</a> <a id="3058" class="Symbol">:</a> <a id="3060" href="Prop.html#3046" class="Bound">A</a> <a id="3062" class="Symbol">→</a> <a id="3064" class="PrimitiveType">Set</a><a id="3067" class="Symbol">)</a> <a id="3069" class="Symbol">:</a> <a id="3071" class="PrimitiveType">Set</a> <a id="3075" class="Keyword">where</a>
      <a id="3087" class="Keyword">constructor</a> <a id="Exists.!Ex._!,,_" href="Prop.html#Exists.%21Ex._%21%2C%2C_" class="InductiveConstructor Operator">_!,,_</a>
      <a id="3111" class="Keyword">field</a>
        <a id="Exists.!Ex.!fst" href="Prop.html#Exists.%21Ex.%21fst" class="Field">!fst</a> <a id="3130" class="Symbol">:</a> <a id="3132" href="Prop.html#3046" class="Bound">A</a>
        <a id="Exists.!Ex.!snd" href="Prop.html#Exists.%21Ex.%21snd" class="Field">!snd</a> <a id="3147" class="Symbol">:</a> <a id="3149" href="Prop.html#3056" class="Bound">B</a> <a id="3151" href="Prop.html#Exists.%21Ex.%21fst" class="Field">!fst</a>
    <a id="3160" class="Keyword">open</a> <a id="3165" href="Prop.html#%21Ex" class="Module">!Ex</a> <a id="3169" class="Keyword">public</a>

  <a id="3179" class="Comment">-- Type constructor.</a>
  <a id="Exists.Ex" href="Prop.html#Exists.Ex" class="Function">Ex</a> <a id="3205" class="Symbol">:</a> <a id="3207" class="Symbol">(</a><a id="3208" href="Prop.html#3208" class="Bound">A</a> <a id="3210" class="Symbol">:</a> <a id="3212" class="PrimitiveType">Set</a><a id="3215" class="Symbol">)</a> <a id="3217" class="Symbol">→</a> <a id="3219" class="Symbol">(</a><a id="3220" href="Prop.html#3220" class="Bound">B</a> <a id="3222" class="Symbol">:</a> <a id="3224" href="Prop.html#3208" class="Bound">A</a> <a id="3226" class="Symbol">→</a> <a id="3228" class="PrimitiveType">Set</a><a id="3231" class="Symbol">)</a> <a id="3233" class="Symbol">→</a> <a id="3235" class="PrimitiveType">Set</a>
  <a id="3241" href="Prop.html#Exists.Ex" class="Function">Ex</a> <a id="3244" href="Prop.html#3244" class="Bound">A</a> <a id="3246" href="Prop.html#3246" class="Bound">B</a> <a id="3248" class="Symbol">=</a> <a id="3250" href="Prop.html#Exists.%21Ex" class="Record">!Ex</a> <a id="3254" href="Prop.html#3244" class="Bound">A</a> <a id="3256" href="Prop.html#3246" class="Bound">B</a>

  <a id="3261" class="Comment">-- Term constructor. Takes a term a : A and a proof of (B a), and</a>
  <a id="3329" class="Comment">-- produces a proof of ∃ a : A, (B a).</a>
  <a id="Exists._,,_" href="Prop.html#Exists._%2C%2C_" class="Function Operator">_,,_</a> <a id="3375" class="Symbol">:</a> <a id="3377" class="Symbol">{</a><a id="3378" href="Prop.html#3378" class="Bound">A</a> <a id="3380" class="Symbol">:</a> <a id="3382" class="PrimitiveType">Set</a><a id="3385" class="Symbol">}</a> <a id="3387" class="Symbol">{</a><a id="3388" href="Prop.html#3388" class="Bound">B</a> <a id="3390" class="Symbol">:</a> <a id="3392" href="Prop.html#3378" class="Bound">A</a> <a id="3394" class="Symbol">→</a> <a id="3396" class="PrimitiveType">Set</a><a id="3399" class="Symbol">}</a> <a id="3401" class="Symbol">→</a> <a id="3403" class="Symbol">(</a><a id="3404" href="Prop.html#3404" class="Bound">a</a> <a id="3406" class="Symbol">:</a> <a id="3408" href="Prop.html#3378" class="Bound">A</a><a id="3409" class="Symbol">)</a> <a id="3411" class="Symbol">→</a> <a id="3413" class="Symbol">(</a><a id="3414" href="Prop.html#3414" class="Bound">b</a> <a id="3416" class="Symbol">:</a> <a id="3418" href="Prop.html#3388" class="Bound">B</a> <a id="3420" href="Prop.html#3404" class="Bound">a</a><a id="3421" class="Symbol">)</a> <a id="3423" class="Symbol">→</a> <a id="3425" href="Prop.html#Exists.Ex" class="Function">Ex</a> <a id="3428" href="Prop.html#3378" class="Bound">A</a> <a id="3430" href="Prop.html#3388" class="Bound">B</a>
  <a id="3434" href="Prop.html#3434" class="Bound">a</a> <a id="3436" href="Prop.html#Exists._%2C%2C_" class="Function Operator">,,</a> <a id="3439" href="Prop.html#3439" class="Bound">b</a> <a id="3441" class="Symbol">=</a> <a id="3443" href="Prop.html#3434" class="Bound">a</a> <a id="3445" href="Prop.html#Exists.%21Ex._%21%2C%2C_" class="InductiveConstructor Operator">!,,</a> <a id="3449" href="Prop.html#3439" class="Bound">b</a>

  <a id="3454" class="Keyword">postulate</a>
    <a id="3468" class="Comment">-- We truncate the term by postulating that it is a proposition.</a>
    <a id="Exists.Ex-isProp" href="Prop.html#Exists.Ex-isProp" class="Postulate">Ex-isProp</a> <a id="3547" class="Symbol">:</a> <a id="3549" class="Symbol">{</a><a id="3550" href="Prop.html#3550" class="Bound">A</a> <a id="3552" class="Symbol">:</a> <a id="3554" class="PrimitiveType">Set</a><a id="3557" class="Symbol">}</a> <a id="3559" class="Symbol">{</a><a id="3560" href="Prop.html#3560" class="Bound">B</a> <a id="3562" class="Symbol">:</a> <a id="3564" href="Prop.html#3550" class="Bound">A</a> <a id="3566" class="Symbol">→</a> <a id="3568" class="PrimitiveType">Set</a><a id="3571" class="Symbol">}</a> <a id="3573" class="Symbol">→</a> <a id="3575" href="Prop.html#isProp" class="Function">isProp</a> <a id="3582" class="Symbol">(</a><a id="3583" href="Prop.html#Exists.Ex" class="Function">Ex</a> <a id="3586" href="Prop.html#3550" class="Bound">A</a> <a id="3588" href="Prop.html#3560" class="Bound">B</a><a id="3589" class="Symbol">)</a>

  <a id="3594" class="Comment">-- Recursion principle for existential quantifiers.</a>
  <a id="Exists.Ex-elim" href="Prop.html#Exists.Ex-elim" class="Function">Ex-elim</a> <a id="3656" class="Symbol">:</a> <a id="3658" class="Symbol">{</a><a id="3659" href="Prop.html#3659" class="Bound">A</a> <a id="3661" class="Symbol">:</a> <a id="3663" class="PrimitiveType">Set</a><a id="3666" class="Symbol">}</a> <a id="3668" class="Symbol">{</a><a id="3669" href="Prop.html#3669" class="Bound">B</a> <a id="3671" class="Symbol">:</a> <a id="3673" href="Prop.html#3659" class="Bound">A</a> <a id="3675" class="Symbol">→</a> <a id="3677" class="PrimitiveType">Set</a><a id="3680" class="Symbol">}</a> <a id="3682" class="Symbol">{</a><a id="3683" href="Prop.html#3683" class="Bound">P</a> <a id="3685" class="Symbol">:</a> <a id="3687" class="PrimitiveType">Set</a><a id="3690" class="Symbol">}</a> <a id="3692" class="Symbol">→</a> <a id="3694" href="Prop.html#Exists.Ex" class="Function">Ex</a> <a id="3697" href="Prop.html#3659" class="Bound">A</a> <a id="3699" href="Prop.html#3669" class="Bound">B</a> <a id="3701" class="Symbol">→</a> <a id="3703" href="Prop.html#isProp" class="Function">isProp</a> <a id="3710" href="Prop.html#3683" class="Bound">P</a> <a id="3712" class="Symbol">→</a> <a id="3714" class="Symbol">(</a><a id="3715" href="Base.html#%CE%A3" class="Record">Σ</a> <a id="3717" href="Prop.html#3659" class="Bound">A</a> <a id="3719" href="Prop.html#3669" class="Bound">B</a> <a id="3721" class="Symbol">→</a> <a id="3723" href="Prop.html#3683" class="Bound">P</a><a id="3724" class="Symbol">)</a> <a id="3726" class="Symbol">→</a> <a id="3728" href="Prop.html#3683" class="Bound">P</a>
  <a id="3732" href="Prop.html#Exists.Ex-elim" class="Function">Ex-elim</a> <a id="3740" class="Symbol">(</a><a id="3741" href="Prop.html#3741" class="Bound">a</a> <a id="3743" href="Prop.html#Exists.%21Ex._%21%2C%2C_" class="InductiveConstructor Operator">!,,</a> <a id="3747" href="Prop.html#3747" class="Bound">b</a><a id="3748" class="Symbol">)</a> <a id="3750" class="Symbol">_</a> <a id="3752" href="Prop.html#3752" class="Bound">f</a> <a id="3754" class="Symbol">=</a> <a id="3756" href="Prop.html#3752" class="Bound">f</a> <a id="3758" class="Symbol">(</a><a id="3759" href="Prop.html#3741" class="Bound">a</a> <a id="3761" href="Base.html#%CE%A3._%2C_" class="InductiveConstructor Operator">,</a> <a id="3763" href="Prop.html#3747" class="Bound">b</a><a id="3764" class="Symbol">)</a>

  <a id="3769" class="Comment">-- Special syntax for quantifiers.</a>
  <a id="3806" class="Keyword">syntax</a> <a id="3813" href="Prop.html#Exists.Ex" class="Function">Ex</a> A <a id="3818" class="Symbol">(λ</a> a <a id="3823" class="Symbol">→</a> e<a id="3826" class="Symbol">)</a> <a id="3828" class="Symbol">=</a> ∃ a ∈ A , e

<a id="3843" class="Keyword">open</a> <a id="3848" href="Prop.html#Exists" class="Module">Exists</a> <a id="3855" class="Keyword">public</a>



<a id="3865" class="Keyword">module</a> <a id="Or" href="Prop.html#Or" class="Module">Or</a> <a id="3875" class="Keyword">where</a>
  <a id="3883" class="Comment">-- The existential disjunction, in a classical sense, arises as a</a>
  <a id="3951" class="Comment">-- propositional truncation of the constructive pair of types. It is</a>
  <a id="4022" class="Comment">-- defined following the same rules and truncating the resulting</a>
  <a id="4089" class="Comment">-- type.</a>
  <a id="4100" class="Keyword">private</a>
    <a id="4112" class="Keyword">data</a> <a id="Or._!∨_" href="Prop.html#Or._%21%E2%88%A8_" class="Datatype Operator">_!∨_</a> <a id="4122" class="Symbol">(</a><a id="4123" href="Prop.html#4123" class="Bound">A</a> <a id="4125" href="Prop.html#4125" class="Bound">B</a> <a id="4127" class="Symbol">:</a> <a id="4129" class="PrimitiveType">Set</a><a id="4132" class="Symbol">)</a> <a id="4134" class="Symbol">:</a> <a id="4136" class="PrimitiveType">Set</a> <a id="4140" class="Keyword">where</a>
      <a id="Or._!∨_.!inl" href="Prop.html#Or._%21%E2%88%A8_.%21inl" class="InductiveConstructor">!inl</a> <a id="4157" class="Symbol">:</a> <a id="4159" href="Prop.html#4123" class="Bound">A</a> <a id="4161" class="Symbol">→</a> <a id="4163" href="Prop.html#4123" class="Bound">A</a> <a id="4165" href="Prop.html#Or._%21%E2%88%A8_" class="Datatype Operator">!∨</a> <a id="4168" href="Prop.html#4125" class="Bound">B</a>
      <a id="Or._!∨_.!inr" href="Prop.html#Or._%21%E2%88%A8_.%21inr" class="InductiveConstructor">!inr</a> <a id="4181" class="Symbol">:</a> <a id="4183" href="Prop.html#4125" class="Bound">B</a> <a id="4185" class="Symbol">→</a> <a id="4187" href="Prop.html#4123" class="Bound">A</a> <a id="4189" href="Prop.html#Or._%21%E2%88%A8_" class="Datatype Operator">!∨</a> <a id="4192" href="Prop.html#4125" class="Bound">B</a>

  <a id="4197" class="Comment">-- Type constructor.</a>
  <a id="Or._∨_" href="Prop.html#Or._%E2%88%A8_" class="Function Operator">_∨_</a> <a id="4224" class="Symbol">:</a> <a id="4226" class="Symbol">(</a><a id="4227" href="Prop.html#4227" class="Bound">A</a> <a id="4229" href="Prop.html#4229" class="Bound">B</a> <a id="4231" class="Symbol">:</a> <a id="4233" class="PrimitiveType">Set</a><a id="4236" class="Symbol">)</a> <a id="4238" class="Symbol">→</a> <a id="4240" class="PrimitiveType">Set</a>
  <a id="4246" href="Prop.html#4246" class="Bound">A</a> <a id="4248" href="Prop.html#Or._%E2%88%A8_" class="Function Operator">∨</a> <a id="4250" href="Prop.html#4250" class="Bound">B</a> <a id="4252" class="Symbol">=</a> <a id="4254" href="Prop.html#4246" class="Bound">A</a> <a id="4256" href="Prop.html#Or._%21%E2%88%A8_" class="Datatype Operator">!∨</a> <a id="4259" href="Prop.html#4250" class="Bound">B</a>

  <a id="4264" class="Comment">-- Term constructors.</a>
  <a id="Or.rinl" href="Prop.html#Or.rinl" class="Function">rinl</a> <a id="4293" class="Symbol">:</a> <a id="4295" class="Symbol">{</a><a id="4296" href="Prop.html#4296" class="Bound">A</a> <a id="4298" href="Prop.html#4298" class="Bound">B</a> <a id="4300" class="Symbol">:</a> <a id="4302" class="PrimitiveType">Set</a><a id="4305" class="Symbol">}</a> <a id="4307" class="Symbol">→</a> <a id="4309" href="Prop.html#4296" class="Bound">A</a> <a id="4311" class="Symbol">→</a> <a id="4313" href="Prop.html#4296" class="Bound">A</a> <a id="4315" href="Prop.html#Or._%E2%88%A8_" class="Function Operator">∨</a> <a id="4317" href="Prop.html#4298" class="Bound">B</a>
  <a id="4321" href="Prop.html#Or.rinl" class="Function">rinl</a> <a id="4326" href="Prop.html#4326" class="Bound">a</a> <a id="4328" class="Symbol">=</a> <a id="4330" href="Prop.html#Or._%21%E2%88%A8_.%21inl" class="InductiveConstructor">!inl</a> <a id="4335" href="Prop.html#4326" class="Bound">a</a>

  <a id="Or.rinr" href="Prop.html#Or.rinr" class="Function">rinr</a> <a id="4345" class="Symbol">:</a> <a id="4347" class="Symbol">{</a><a id="4348" href="Prop.html#4348" class="Bound">A</a> <a id="4350" href="Prop.html#4350" class="Bound">B</a> <a id="4352" class="Symbol">:</a> <a id="4354" class="PrimitiveType">Set</a><a id="4357" class="Symbol">}</a> <a id="4359" class="Symbol">→</a> <a id="4361" href="Prop.html#4350" class="Bound">B</a> <a id="4363" class="Symbol">→</a> <a id="4365" href="Prop.html#4348" class="Bound">A</a> <a id="4367" href="Prop.html#Or._%E2%88%A8_" class="Function Operator">∨</a> <a id="4369" href="Prop.html#4350" class="Bound">B</a>
  <a id="4373" href="Prop.html#Or.rinr" class="Function">rinr</a> <a id="4378" href="Prop.html#4378" class="Bound">b</a> <a id="4380" class="Symbol">=</a> <a id="4382" href="Prop.html#Or._%21%E2%88%A8_.%21inr" class="InductiveConstructor">!inr</a> <a id="4387" href="Prop.html#4378" class="Bound">b</a>

  <a id="4392" class="Keyword">postulate</a>
    <a id="4406" class="Comment">-- We truncate the type by postulating that it must be a</a>
    <a id="4467" class="Comment">-- proposition.</a>
    <a id="Or.∨-isProp" href="Prop.html#Or.%E2%88%A8-isProp" class="Postulate">∨-isProp</a> <a id="4496" class="Symbol">:</a> <a id="4498" class="Symbol">{</a><a id="4499" href="Prop.html#4499" class="Bound">A</a> <a id="4501" href="Prop.html#4501" class="Bound">B</a> <a id="4503" class="Symbol">:</a> <a id="4505" class="PrimitiveType">Set</a><a id="4508" class="Symbol">}</a> <a id="4510" class="Symbol">→</a> <a id="4512" href="Prop.html#isProp" class="Function">isProp</a> <a id="4519" class="Symbol">(</a><a id="4520" href="Prop.html#4499" class="Bound">A</a> <a id="4522" href="Prop.html#Or._%E2%88%A8_" class="Function Operator">∨</a> <a id="4524" href="Prop.html#4501" class="Bound">B</a><a id="4525" class="Symbol">)</a>

  <a id="4530" class="Comment">-- Recursion principle.</a>
  <a id="Or.∨-elim" href="Prop.html#Or.%E2%88%A8-elim" class="Function">∨-elim</a> <a id="4563" class="Symbol">:</a> <a id="4565" class="Symbol">{</a><a id="4566" href="Prop.html#4566" class="Bound">A</a> <a id="4568" href="Prop.html#4568" class="Bound">B</a> <a id="4570" href="Prop.html#4570" class="Bound">P</a> <a id="4572" class="Symbol">:</a> <a id="4574" class="PrimitiveType">Set</a><a id="4577" class="Symbol">}</a> <a id="4579" class="Symbol">→</a> <a id="4581" href="Prop.html#4566" class="Bound">A</a> <a id="4583" href="Prop.html#Or._%E2%88%A8_" class="Function Operator">∨</a> <a id="4585" href="Prop.html#4568" class="Bound">B</a> <a id="4587" class="Symbol">→</a> <a id="4589" href="Prop.html#isProp" class="Function">isProp</a> <a id="4596" href="Prop.html#4570" class="Bound">P</a> <a id="4598" class="Symbol">→</a> <a id="4600" class="Symbol">((</a><a id="4602" href="Prop.html#4566" class="Bound">A</a> <a id="4604" href="Base.html#_%E2%8A%8E_" class="Datatype Operator">⊎</a> <a id="4606" href="Prop.html#4568" class="Bound">B</a><a id="4607" class="Symbol">)</a> <a id="4609" class="Symbol">→</a> <a id="4611" href="Prop.html#4570" class="Bound">P</a><a id="4612" class="Symbol">)</a> <a id="4614" class="Symbol">→</a> <a id="4616" href="Prop.html#4570" class="Bound">P</a>
  <a id="4620" href="Prop.html#Or.%E2%88%A8-elim" class="Function">∨-elim</a> <a id="4627" class="Symbol">(</a><a id="4628" href="Prop.html#Or._%21%E2%88%A8_.%21inl" class="InductiveConstructor">!inl</a> <a id="4633" href="Prop.html#4633" class="Bound">x</a><a id="4634" class="Symbol">)</a> <a id="4636" class="Symbol">_</a> <a id="4638" href="Prop.html#4638" class="Bound">f</a> <a id="4640" class="Symbol">=</a> <a id="4642" href="Prop.html#4638" class="Bound">f</a> <a id="4644" class="Symbol">(</a><a id="4645" href="Base.html#_%E2%8A%8E_.inl" class="InductiveConstructor">inl</a> <a id="4649" href="Prop.html#4633" class="Bound">x</a><a id="4650" class="Symbol">)</a>
  <a id="4654" href="Prop.html#Or.%E2%88%A8-elim" class="Function">∨-elim</a> <a id="4661" class="Symbol">(</a><a id="4662" href="Prop.html#Or._%21%E2%88%A8_.%21inr" class="InductiveConstructor">!inr</a> <a id="4667" href="Prop.html#4667" class="Bound">x</a><a id="4668" class="Symbol">)</a> <a id="4670" class="Symbol">_</a> <a id="4672" href="Prop.html#4672" class="Bound">f</a> <a id="4674" class="Symbol">=</a> <a id="4676" href="Prop.html#4672" class="Bound">f</a> <a id="4678" class="Symbol">(</a><a id="4679" href="Base.html#_%E2%8A%8E_.inr" class="InductiveConstructor">inr</a> <a id="4683" href="Prop.html#4667" class="Bound">x</a><a id="4684" class="Symbol">)</a>
<a id="4686" class="Keyword">open</a> <a id="4691" href="Prop.html#Or" class="Module">Or</a> <a id="4694" class="Keyword">public</a>


<a id="4703" class="Comment">-- Uniqueness of identity proofs, or Axiom K.  We choose to allow this</a>
<a id="4774" class="Comment">-- rule in our theory inside this library in order to ease some</a>
<a id="4838" class="Comment">-- proofs, but it will be forbidden inside the homotopy-theoretical</a>
<a id="4906" class="Comment">-- version.</a>
<a id="uip" href="Prop.html#uip" class="Function">uip</a> <a id="4922" class="Symbol">:</a> <a id="4924" class="Symbol">{</a><a id="4925" href="Prop.html#4925" class="Bound">A</a> <a id="4927" class="Symbol">:</a> <a id="4929" class="PrimitiveType">Set</a><a id="4932" class="Symbol">}</a> <a id="4934" class="Symbol">→</a> <a id="4936" class="Symbol">{</a><a id="4937" href="Prop.html#4937" class="Bound">a</a> <a id="4939" href="Prop.html#4939" class="Bound">b</a> <a id="4941" class="Symbol">:</a> <a id="4943" href="Prop.html#4925" class="Bound">A</a><a id="4944" class="Symbol">}</a> <a id="4946" class="Symbol">→</a> <a id="4948" href="Prop.html#isProp" class="Function">isProp</a> <a id="4955" class="Symbol">(</a><a id="4956" href="Prop.html#4937" class="Bound">a</a> <a id="4958" href="Base.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="4960" href="Prop.html#4939" class="Bound">b</a><a id="4961" class="Symbol">)</a>
<a id="4963" href="Prop.html#uip" class="Function">uip</a> <a id="4967" class="Symbol">{</a><a id="4968" href="Prop.html#4968" class="Bound">A</a><a id="4969" class="Symbol">}</a> <a id="4971" class="Symbol">{</a><a id="4972" href="Prop.html#4972" class="Bound">a</a><a id="4973" class="Symbol">}</a> <a id="4975" class="Symbol">{</a><a id="4976" class="DottedPattern Symbol">.</a><a id="4977" href="Prop.html#4972" class="DottedPattern Bound">a</a><a id="4978" class="Symbol">}</a> <a id="4980" href="Base.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a> <a id="4985" href="Base.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a> <a id="4990" class="Symbol">=</a> <a id="4992" href="Base.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a>
</pre></body></html>