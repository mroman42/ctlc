#+TITLE: Category Theory and Lambda Calculus
#+AUTHOR: Mario Román
#+SETUPFILE: ctlc.setup
#+LATEX_HEADER: %\input{titlepage}

** Abstract
:PROPERTIES:
:UNNUMBERED: t
:END:

This is the abstract

* Category theory :noexport:
Those are pre-code comments

#+BEGIN_SRC haskell :export code
main :: IO ()
main = putStrLn "Hello world!"

\newcommand{cosas}
\textit{3^4}

def funcion():
  pass
#+END_SRC

* Lambda calculus
** Untyped lambda calculus
*** TODO Church encoding
*** TODO SKI combinators
** Typed lambda calculus
We will write a presentation of *simply-typed lambda calculus* based
on cite:selinger13.

*** TODO Types and sets
# From the Hott book

*** Simple types
# Are basic types necessary?

We start assuming that a set of *basic types* exists. Those basic
types would correspond, in a programming language interpretation, with
things like the type of strings or the type of integers. We will also
assume that a *unit* type, $1$ exists; the unit type will have only
one inhabitant.

#+begin_definition
The set of *simple types* is given by the following Backus-Naur form
\[\mathtt{Type} ::= 
1 \mid
\iota \mid 
\mathtt{Type} \to \mathtt{Type} \mid
\mathtt{Type} \times \mathtt{Type} \]

where $1$ is a one-element type and $\iota$ is any /basic type/.
#+end_definition

That is to say that, for every two types $A,B$, there exist a *function type*
$A \to B$ and a *pair type* $A \times B$.

*** Raw typed lambda terms
We will now define the terms of the typed lambda calculus. 

#+begin_definition
The set of *typed lambda terms* is given by the BNF
\[ \mathtt{Term} ::=
\ast \mid
x \mid
\mathtt{Term}\mathtt{Term} \mid
\lambda x^{\mathtt{Type}}. \mathtt{Term} \mid
\left\langle \mathtt{Term},\mathtt{Term} \right\rangle \mid
\pi_1 \mathtt{Term} \mid
\pi_2\mathtt{Term}
\]
#+end_definition

Besides the previously considered term application and a special
element $\ast$ which will be the unique inhabitant of the type $1$; we
now introduce a typed lambda abstraction and an explicit construction
of the pair element with its projections.

*** Typing rules for the simply-typed lambda calculus
The set of raw typed lambda terms contains some meaningless terms
under our type interpretation, such as $\pi_1(\lambda x^A.M)$. *Typing rules*
will give them the desired semantics; only a subset of these raw
lambda terms will be typeable.

#+begin_definition
A *typing context* is a sequence of typing assumptions
$x_1:A_1,\dots,x_n:A_n$, where no variable appears more than once.
#+end_definition

Every typing rule assumes a typing context, usually denoted by $\Gamma$ 
or by a concatenation of typing contexts written as $\Gamma,\Gamma'$; and 
a consequence from that context, separated by the $\vdash$ symbol.

 1) The type of $\ast$ is $1$, the rule $(\ast)$ builds this element.

   \begin{prooftree}
   \LeftLabel{($\ast$)}
   \AxiomC{}
   \UnaryInfC{$\Gamma \vdash \ast : 1$}
   \end{prooftree}

 2) The $(var)$ rule simply makes explicit the type of a variable from
    the context.

    \begin{prooftree}
    \LeftLabel{($var$)}
    \AxiomC{}
    \UnaryInfC{$\Gamma, x:A \vdash x:A$}
    \end{prooftree}

 3) The $(pair)$ rule allow us to build pairs by their components. It acts
   as a constructor of pairs.

   \begin{prooftree}
   \LeftLabel{$(pair)$}
   \AxiomC{$\Gamma \vdash a : A$}
   \AxiomC{$\Gamma \vdash b : B$}
   \BinaryInfC{$\Gamma \vdash \left\langle a,b \right\rangle : A \times B$}
   \end{prooftree}

 4) The $(\pi_1)$ and $(\pi_2)$ rules give the semantics of a product
    with two projections to the pair terms. If we have a pair $m : A \times B$, then
    $\pi_1m : A$ and $\pi_2m : B$. They act as two different destructors of pairs.

    \begin{prooftree}
    \LeftLabel{($\pi_1$)}
    \AxiomC{$\Gamma \vdash m : A \times B$}
    \UnaryInfC{$\Gamma \vdash \pi_1m : A$}
    \LeftLabel{($\pi_2$)}
    \AxiomC{$\Gamma \vdash m : A \times B$}
    \UnaryInfC{$\Gamma \vdash \pi_2m : B$}
    \noLine\BinaryInfC{}
    \end{prooftree}

 5) The $(abs)$ introduces a well-typed lambda abstraction. If we have a
    $h : B$ term depending on $x : A$, we can create a lambda abstraction
    from this term. It acts as a constructor of function terms.

    \begin{prooftree}
    \LeftLabel{($abs$)}
    \AxiomC{$\Gamma, x : A \vdash h : B$}
    \UnaryInfC{$\Gamma \vdash \lambda x^A.h : A \to B$}
    \end{prooftree}

 6) The $(app)$ rule gives the type of a well-typed application of a
    lambda term. A term $f : A \to B$ applied to a term $a : A$ is a term
    of type $B$. It acts as a destructor of function terms.

    \begin{prooftree}
    \LeftLabel{$(app)$}
    \AxiomC{$\Gamma \vdash f : A \to B$}
    \AxiomC{$\Gamma \vdash a : A$}
    \BinaryInfC{$\Gamma \vdash f a : B$}
    \end{prooftree}

#+begin_definition
A term is *typable* if we can assign types to all its variables in
such a way that a typing judgment for the type is derivable.
#+end_definition

# Examples of typable and non-typable terms.

# It is easy to check if a term is typable because there is only
# one way to type it.

# If we want to derive term bottom-up, there is only one possible
# choice at each step. Has this to do with the natural deduction
# properties?

*** TODO Natural deduction
# Every derivation in natural deduction is exactly a lambda term.

** TODO System F
* Type theory                                                      :noexport:
** TODO Propositions as types
** TODO Martin-Löf Type Theory
** TODO Type theory as a foundation of mathematics
** TODO Constructive mathematics
*** TODO Proof by contradiction and proof of a negation
# They are fundamentally different
#
# [[https://www.youtube.com/watch?v=21qPOReu4FI][Five stages of accepting constructive mathematics]]
*** TODO Axiom of choice implies excluded middle
# In Agda or Coq!?
** TODO Homotopy Type Theory
* Mikrokosmos (abstract)                                             :ignore:
#+LATEX: \ctparttext{\color{black}\begin{center}
We have developed *Mikrokosmos*, a lambda calculus interpreter
written in the purely functional programming language Haskell cite:hudak07_haskell.
It aims to provide students with a tool to learn and understand lambda calculus.
#+LATEX: \end{center}}

* Mikrokosmos
** Parsec
https://web.archive.org/web/20120401040711/http://legacy.cs.uu.nl/daan/download/parsec/parsec.pdf

*** Monadic parsers
http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf
https://ncatlab.org/nlab/files/WadlerMonads.pdf

** Syntax 
** Jupyter kernel
The *Jupyter Project* cite:jupyter is an open source project providing
support for interactive scientific computing. Specifically, the
Jupyter Notebook provides a web application for creating interactive
documents with live code and visualizations. 

We have developed a Mikrokosmos kernel for the Jupyter Notebook,
allowing the user to write and execute arbitrary Mikrokosmos code
on this web application.

# Image of the mikrokosmos jupyter notebook

*** CodeMirror lexer
* Conclusions
bibliographystyle:alpha
bibliography:Bibliography.bib
